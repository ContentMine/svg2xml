package org.xmlcml.svg2xml.action;

import java.io.File;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import nu.xom.Attribute;
import nu.xom.Comment;
import nu.xom.Element;
import nu.xom.Elements;
import nu.xom.Node;
import nu.xom.ProcessingInstruction;
import nu.xom.Text;

import org.apache.log4j.Logger;
import org.xmlcml.cml.base.CMLConstants;
import org.xmlcml.cml.base.CMLUtil;
import org.xmlcml.graphics.svg.SVGElement;
import org.xmlcml.graphics.svg.SVGSVG;
import org.xmlcml.graphics.svg.SVGUtil;

/** generated by an AbstractActionX
 * contains the attribute logic because some commands have different actions
 *  
 * @author pm286
 *
 */
public abstract class AbstractActionX extends Element {

	private final static Logger LOG = Logger.getLogger(AbstractActionX.class);
	
	public final static Pattern VARIABLE_REF = Pattern.compile("\\$\\{([^\\{]*)\\}");
	private static final String TRUE = "true";

	public static final String ACTION = "action";
	public static final String DELETE_NAMESPACES = "deleteNamespaces";
	public static final String FILENAME = "filename";
	public static final String FORMAT = "format";
	public static final String MARK = "mark";
	public static final String DEBUG = "debug";
	public static final String COUNT = "count";
	public static final String LOGAT = "log";
	public static final String MESSAGE = "message";
	public static final String NAME = "name";
	public static final String OUT_DIR = "outDir";
	public static final String REGEX = "regex";
	public static final String SKIP_IF_EXISTS = "skipIfExists";
	public static final String TITLE = "title";
	public static final String XPATH = "xpath";
	public static final String MAX = "max";
	public static final String TIMEOUT = "timeout";

	public static final String EXIT = "exit";

	public static final String VARIABLES = "variables";

	public static final String TYPE = "type";
	protected static final String OUTFILE = "outfile";

	public static final String INFILE = "infile";

	protected static final String OUTDIR = "outputDir";

	
	protected SemanticDocumentActionX semanticDocumentActionX;

	/** constructor.
	 * 
	 * @param name
	 */
	public AbstractActionX(String name) {
		super(name);
		init();
	}

	/** constructor.
	 * 
	 * @param name
	 */
	public AbstractActionX(AbstractActionX abstractActionX) {
		super(abstractActionX);
		init();
	}

	protected void init() {
//		this.abstractAction = createAction();
	}
	
	/** check attributes */
	protected abstract List<String> getAttributeNames();
	protected abstract List<String> getRequiredAttributeNames();
	
//	protected abstract AbstractAction createAction();

	public void checkAttributes() {
		List<String> allowedNames = getAttributeNames();
		if (allowedNames == null) {
			throw new RuntimeException("Must give some allowed attributes: "+this.getClass());
		}
		List<String> attNames = new ArrayList<String>();
		for (int i = 0; i < this.getAttributeCount(); i++) {
			String attName = this.getAttribute(i).getLocalName();
			if (!allowedNames.contains(attName)) {
				throw new RuntimeException("Unknown attribute : "+attName+" on "+this.getClass());
			}
			attNames.add(attName);
		}
		List<String> requiredNames = getRequiredAttributeNames();
		if (requiredNames != null) {
			for (String requiredName : requiredNames) {
				if (!attNames.contains(requiredName)) {
					throw new RuntimeException("Missing attribute : "+requiredName+" on "+this.getClass()+" // "+this.toXML());
				}
			}
		}
	}

	/** copy constructor from non-subclassed elements
	 */
	public static AbstractActionX createActionX(Element element) {
		AbstractActionX newElement = null;
		String tag = element.getLocalName();
		LOG.trace("TAG "+tag);
		if (tag == null || tag.equals("")) {
			throw new RuntimeException("no tag");
		} else if (tag.equals(AssertActionX.TAG)) {
			newElement = new AssertActionX();
		} else if (tag.equals(BoxDrawerActionX.TAG)) {
			newElement = new BoxDrawerActionX();
		} else if (tag.equals(BoxProcessorActionX.TAG)) {
			newElement = new BoxProcessorActionX();
		} else if (tag.equals(BreakActionX.TAG)) {
			newElement = new BreakActionX();
		} else if (tag.equals(ChunkAnalyzerActionX.TAG)) {
			newElement = new ChunkAnalyzerActionX();
		} else if (tag.equals(DebugActionX.TAG)) {
			newElement = new DebugActionX();
		} else if (tag.equals(DocumentIteratorActionX.TAG)) {
			newElement = new DocumentIteratorActionX();
		} else if (tag.equals(PageIteratorActionX.TAG)) {
			newElement = new PageIteratorActionX();
		} else if (tag.equals(DocumentWriterActionX.TAG)) {
			newElement = new DocumentWriterActionX();
		} else if (tag.equals(ElementStylerActionX.TAG)) {
			newElement = new ElementStylerActionX();
//		} else if (tag.equals(FigureAnalyzerActionX.TAG)) {
//			newElement = new FigureAnalyzerActionX();
		} else if (tag.equals(IncludeActionX.TAG)) {
			newElement = new IncludeActionX();
		} else if (tag.equals(NodeDeleterActionX.TAG)) {
			newElement = new NodeDeleterActionX();
		} else if (tag.equals(PageNormalizerActionX.TAG)) {
			newElement = new PageNormalizerActionX();
		} else if (tag.equals(VariableActionX.TAG)) {
			newElement = new VariableActionX();
		} else if (tag.equals(PageWriterActionX.TAG)) {
			newElement = new PageWriterActionX();
		} else if (tag.equals(PathNormalizerActionX.TAG)) {
			newElement = new PathNormalizerActionX();
		} else if (tag.equals(SemanticDocumentActionX.TAG)) {
			newElement = new SemanticDocumentActionX();
		} else if (tag.equals(TextChunkerActionX.TAG)) {
			newElement = new TextChunkerActionX();
		} else if (tag.equals(VariableExtractorActionX.TAG)) {
			newElement = new VariableExtractorActionX();
		} else if (tag.equals(WhitespaceChunkerActionX.TAG)) {
			newElement = new WhitespaceChunkerActionX();
		} else {
			throw new RuntimeException("unsupported element: "+tag);
		}
		if (newElement != null) {
			CMLUtil.copyAttributes(element, newElement);
	        createSubclassedChildren(element, newElement);
	        ((AbstractActionX)newElement).checkAttributes();
		}
        return newElement;
		
	}
	
	protected static void createSubclassedChildren(Element oldElement, AbstractActionX newElement) {
		if (oldElement != null) {
			for (int i = 0; i < oldElement.getChildCount(); i++) {
				Node node = oldElement.getChild(i);
				Node newNode = null;
				if (node instanceof Text) {
					newNode = new Text(node.getValue());
				} else if (node instanceof Comment) {
					newNode = new Comment(node.getValue());
				} else if (node instanceof ProcessingInstruction) {
					newNode = new ProcessingInstruction((ProcessingInstruction) node);
				} else if (node instanceof Element) {
					newNode = createActionX((Element) node);
				} else {
					throw new RuntimeException("Cannot create new node: "+node.getClass());
				}
				newElement.appendChild(newNode);
			}
		}
	}

	public AbstractActionX getSemanticDocumentElement() {
		if (semanticDocumentActionX == null) {
			Element element = (Element) this.query("/*").get(0);
			if (element instanceof SemanticDocumentActionX) {
				semanticDocumentActionX = (SemanticDocumentActionX) element;
			}
		}
		return semanticDocumentActionX;
	}
	
	public String getString() {
		StringBuilder sb = new StringBuilder();
		sb.append(this.getLocalName()+"\n");
		for (int i = 0; i < this.getAttributeCount(); i++) {
			Attribute attribute = this.getAttribute(i);
			sb.append(" "+attribute.getLocalName()+"='"+attribute.getValue()+"'");
		}
		sb.append("\n");
		return sb.toString();
	}
	
	public void debug(String msg) {
		CMLUtil.debug(this, msg);
	}

	
	/** only used for constructing objects programmatically
	 * 
	 */
	protected AbstractActionX() {
		super("dummy");
	}

	/** execute the command
	 * 
	 */
	public abstract void run();

	public void setSemanticDocumentX(SemanticDocumentActionX semanticDocumentX) {
		this.semanticDocumentActionX = semanticDocumentX;
	}
	
	public String getFilename() {
		String filename = getAndExpand(AbstractActionX.FILENAME);
		if (filename != null) {
			try {
				filename = new File(filename).getCanonicalPath();
			} catch (Exception e) {
				throw new RuntimeException("Bad filename: "+filename);
			}
		}
		return filename;
	}

	public String getName() {
		return getAndExpand(AbstractActionX.NAME);
	}

	public String getMark() {
		return getAndExpand(AbstractActionX.MARK);
	}

	protected String getAndExpand(String attName) {
		String value =this.getAttributeValue(attName);
		return expandVariables(value);
	}

	protected String getAndExpand(String attName, String defaultValue) {
		String value = getValue(attName, defaultValue);
		return expandVariables(value);
	}

	public String getType() {
		return getAndExpand(AbstractActionX.TYPE);
	}

	protected String getValue(String attName, String defaultValue) {
		String value = this.getAttributeValue(attName);
		value = (value == null) ? defaultValue : value;
		return value;
	}

	public String[] getDeleteNamespaces() {
		String s = getAndExpand(AbstractActionX.DELETE_NAMESPACES);
		String[] ss = null;
		if (s != null) {
			ss = s.split(CMLConstants.S_WHITEREGEX);
		}
		return ss;
	}

	public Boolean getDebug() {
		String  debugString = getAndExpand(AbstractActionX.DEBUG);
		return debugString == null ? null : TRUE.equalsIgnoreCase(debugString);
	}

	public String getFormat() {
		return getAndExpand(AbstractActionX.FORMAT);
	}

	public String getFormat(String defaultFormat) {
		String format = getAndExpand(AbstractActionX.FORMAT);
		return format == null ? defaultFormat : format;
	}

	public String getLog() {
		return getAndExpand(AbstractActionX.LOGAT);
	}

	protected boolean isTrue(String attName) {
		String val = getAndExpand(attName);
		return new Boolean(val);
	}

	/** gets Integer from attribute
	 * fails silently
	 * 
	 * @param name attributeName
	 * @return
	 */
	protected Integer getInteger(String name) {
		Integer ii = null;
		String s = getAndExpand(name);
		try {
			ii = new Integer(s);
		} catch (Exception e) {
		}
		return ii;
	}

	/** gets Integer from attribute
	 * fails silently
	 * 
	 * @param name attributeName
	 * @param defaultValue
	 * @return
	 */
	protected Integer getInteger(String name, Integer defaultValue) {
		Integer ii = getInteger(name);
		return ii == null ? defaultValue : ii;
	}

	/** gets Long from attribute
	 * fails silently
	 * 
	 * @param name attributeName
	 * @return
	 */
	protected Long getLong(String name) {
		Long ll = null;
		String s = getAndExpand(name);
		try {
			ll = new Long(s);
		} catch (Exception e) {
		}
		return ll;
	}

	/** gets Long from attribute
	 * fails silently
	 * 
	 * @param name attributeName
	 * @param defaultValue
	 * @return
	 */
	protected Long getLong(String name, Long defaultValue) {
		Long ii = getLong(name);
		return ii == null ? defaultValue : ii;
	}

	/** gets Double from attribute
	 * fails silently
	 * 
	 * @param name attributeName
	 * @return
	 */
	protected Double getDouble(String name) {
		Double dd = null;
		String s = getAndExpand(name);
		try {
			dd = new Double(s);
		} catch (Exception e) {
		}
		return dd;
	}

	/** gets Double from attribute
	 * fails silently
	 * 
	 * @param name attributeName
	 * @param defaultValue
	 * @return
	 */
	protected Double getDouble(String name, Double defaultValue) {
		Double dd = getDouble(name);
		return dd == null ? defaultValue : dd;
	}

	public String getActionValue() {
		return getAndExpand(AbstractActionX.ACTION);
	}

	protected String expandVariables(String value) {
		String val = null;
		if (value != null) {
			Matcher matcher = VARIABLE_REF.matcher(value);
			StringBuilder sb = new StringBuilder();
			int current = 0;
			while (matcher.find()) {
				int start = matcher.start();
				sb.append(value.substring(current, start));
				int end = matcher.end();
				String name = matcher.group(1);
				Object newValue = semanticDocumentActionX.getVariable(name);
				if (newValue == null) {
					throw new RuntimeException("Cannot find variable: "+name+" in "+value);
				}
				if (newValue instanceof String || newValue instanceof File || newValue instanceof Number) {
					sb.append(newValue.toString());
				} else {
					sb.append(newValue.getClass());
				}
				current = end;
			}
			sb.append(value.substring(current));
			val = sb.toString();
		}
		return val;
	}
	
	public String getCount() {
		return getAndExpand(AbstractActionX.COUNT);
	}

	public String getMessage() {
		// don't expand this
		return this.getAttributeValue(AbstractActionX.MESSAGE);
	}

	public String getRegex() {
		// don't expand this
		return this.getAttributeValue(AbstractActionX.REGEX);
	}

	/** gets skip attribute value or null
	 * 
	 * @return
	 */
	public String getSkip() {
		String skip = getAndExpand(AbstractActionX.SKIP_IF_EXISTS);
		return skip;
	}

	/** splits the skip string by whitespace
	 * 
	 * @return empty list if missing
	 */
	public List<String> getSkipList() {
		List<String> skipList = new ArrayList<String>();
		String skip = getSkip();
		if (skip != null) {
			String[] skips = skip.split(CMLConstants.S_WHITEREGEX);
			skipList = Arrays.asList(skips);
		}
		return skipList;
	}

	public Long getTimeout(long defaultTimeout) {
		return getLong(AbstractActionX.TIMEOUT);
	}

	public String getTitle() {
		// don't expand this
		return this.getAttributeValue(AbstractActionX.TITLE);
	}

	public String getValueString() {
		return getAndExpand(PageActionX.VALUE);
	}

	public String getXPath() {
		return getAndExpand(AbstractActionX.XPATH);
	}

	protected List<AbstractActionX> getChildActionList() {
		Elements childElements = this.getChildElements();
		List<AbstractActionX> childActionList = new ArrayList<AbstractActionX>();
		for (int i = 0; i < childElements.size(); i++) {
			Element childActionX = childElements.get(i);
			if (!(childActionX instanceof AbstractActionX)) {
				throw new RuntimeException("Element not allowed: "+childActionX.toXML());
			}
			AbstractActionX actionX = (AbstractActionX) childActionX;
//			AbstractActionX abstractAction = actionElement.getAction();
			childActionList.add(actionX);
		}
		return childActionList;
	}

	protected void runChildActionList() {
		List<AbstractActionX> childActionList = getChildActionList();
		if (childActionList.size() == 0) {
			LOG.debug("*** No child actions given ***");
		}
		for (AbstractActionX abstractAction : childActionList) {
			LOG.trace("running: "+abstractAction);
			// maybe put filter in here
			abstractAction.run();
		}
	}

	/** the variable is also available as protected
	 * 
	 * @return
	 */
	public AbstractActionX getSemanticDocumentX() {
		if (semanticDocumentActionX == null && this instanceof SemanticDocumentActionX) {
			semanticDocumentActionX = (SemanticDocumentActionX) this;
		}
		return semanticDocumentActionX;
	}

	public SVGSVG getSVGPage() {
		getSemanticDocumentX();
		PageEditorX pageEditor = semanticDocumentActionX.getPageEditor();
		return pageEditor == null ? null : pageEditor.getSVGPage();
	}

	public void setSemanticDocumentActionX(SemanticDocumentActionX semanticDocumentActionX) {
		this.semanticDocumentActionX = semanticDocumentActionX;
	}

	protected void fail(String string) {
		String fail = getFail();
		if (EXIT.equalsIgnoreCase(fail)) {
			throw new RuntimeException(string+" ... "+this.toXML());
		} else {
			LOG.error("******** FAIL: "+string+" *************");
		}
	}

	protected void warn(String string) {
		LOG.error("******** WARN: "+string+" *************");
	}

	protected void info(String string) {
		LOG.error("******** INFO: "+string+" *************");
	}

	protected void log(String string) {
		info(string);
	}

	protected void debugFile(String filename) {
		SVGSVG svg = new SVGSVG(getSVGPage());
		List<SVGElement> defs = SVGUtil.getQuerySVGElements(svg, ".//svg:defs");
		for (SVGElement def : defs) def.detach();
		CMLUtil.outputQuietly(svg, new File(filename), 1);
	}

	public String getFail() {
		return getAndExpand(PageActionX.FAIL);
	}

	public List<String> getVariables() {
		String s = this.getAttributeValue(AbstractActionX.VARIABLES);
		String[] ss = (s == null) ? null : s.split(CMLConstants.S_WHITEREGEX);
		return (ss == null) ? null : Arrays.asList(ss);
	}

	public AbstractActionX getSemanticDocumentActionX() {
		return semanticDocumentActionX;
	}
}
